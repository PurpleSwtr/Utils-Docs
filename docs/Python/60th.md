В одном из телеграм-каналов однажды наткнулся на рубрику в нескольких постах, где в таких маленьких зарисовках рассказывали компактные решения, фичи и тд.

Вот архивчик всего того что я нашёл:

1.  **`list(Path('.').rglob('*.py'))`** -> Рекурсивный поиск всех файлов с расширением `.py` в текущей директории и поддиректориях.
2.  **`timeit(lambda: your_func(), number=1000)`** -> Быстрый замер скорости выполнения кода (запускает `your_func` 1000 раз и возвращает общее время).
3.  **`[m for m in dir(obj) if not m.startswith('_')]`** -> Получение списка всех публичных методов и атрибутов объекта.
4.  **`df.dropna()`** -> Удаление всех строк с пропущенными значениями (NaN) из DataFrame в pandas.
5.  **`list(ThreadPoolExecutor().map(func, iterable))`** -> Простое распараллеливание: запуск функции `func` для каждого элемента `iterable` в отдельном потоке.
6.  **`dict(Counter(my_list))`** -> Подсчет количества каждого уникального элемента в списке. Возвращает словарь `{элемент: количество}`.
7.  **`[x for x, c in Counter(lst).items() if c > 1]`** -> Поиск всех дубликатов в списке.
8.  **`list(filter(None, data))`** -> Фильтрация списка, удаляющая все "ложные" значения (`None`, `False`, `0`, `""`, `[]`).
9.  **`try: foo() except Exception as e: logging.exception(e)`** -> Конструкция для перехвата любого исключения из функции `foo()` и его логирования с полной трассировкой.
10. **`pd.DataFrame(list_of_dicts)`** -> Превращение списка словарей в таблицу (DataFrame) pandas.
11. **`{v: k for k, v in d.items() if list(d.values()).count(v) == 1}`** -> Инвертирование словаря (ключи становятся значениями и наоборот), но только для уникальных значений.
12. **`start = time(); result = fn(); print(f'{time() - start:.2f}s')`** -> Простейший способ замерить время выполнения одной операции.
13. **`random.sample(big_list, k=100)`** -> Взять 100 случайных, уникальных элементов из большого списка без его изменения.
14. **`max(data, key=lambda x: x.score)`** -> Найти в списке объектов тот, у которого атрибут `score` максимален.
15. **`textwrap.dedent(multiline_string)`** -> Удаление лишних общих отступов слева у многострочной строки.
16. **`[func() for _ in range(5) if not success()][-1]`** -> Хитрый способ повторить вызов `func` до 5 раз, пока `success()` не вернёт `True`.
17. **`json.loads(Path('file.json').read_text())`** -> Чтение JSON-файла и его преобразование в объект Python (словарь или список).
18. **`v /= np.linalg.norm(v)`** -> Нормализация NumPy-вектора (приведение его длины к 1) на месте.
19. **`'\n'.join(f'{k}={v}' for k, v in sorted(os.environ.items()))`** -> Вывод всех переменных окружения в отсортированном по имени виде.
20. **`urlencode(params)`** -> Преобразование словаря `params` в строку запроса для URL (например, `key=value&key2=value2`).
21. **`Path('file.txt').read_text().splitlines()`** -> Чтение текстового файла целиком в список строк, автоматически убирая символы переноса `\n`.
22. **`hashlib.sha256(b"your text").hexdigest()`** -> Получение SHA256-хеша от строки в шестнадцатеричном формате.
23. **`','.join(map(str, numbers))`** -> Преобразование списка чисел в одну строку, где числа разделены запятой.
24. **`raise SystemExit("Done")`** -> Корректный способ остановить выполнение скрипта с сообщением (не считается ошибкой).
25. **`sys.getsizeof(obj)`** -> Получение размера объекта в байтах в памяти.
26. **`[i for sub in nested for i in sub]`** -> "Распрямление" списка списков в один плоский список.
27. **`~mask`** -> Инвертирование булевой маски в NumPy (`True` становится `False` и наоборот).
28. **`seen = set(); [x for x in lst if not (x in seen or seen.add(x))]`** -> Удаление дубликатов из списка с сохранением исходного порядка элементов.
29. **`result = func(**params)`** -> Распаковка словаря `params` в именованные аргументы для функции `func`.
30. **`dict(Counter(lst).most_common(5))`** -> Получение 5 самых часто встречающихся элементов в списке и их количества.
31. **`s[:n] + '…' if len(s) > n else s`** -> Обрезка строки до `n` символов с добавлением многоточия, если она была длиннее.
32. **`[random.randint(0, 1) for _ in range(n)]`** -> Создание списка из `n` случайных нулей и единиц.
33. **`date.today().isoformat()`** -> Получение сегодняшней даты в стандартном формате `YYYY-MM-DD`.
34. **`os.path.getsize(path) / 1024**2`** -> Получение размера файла в мегабайтах.
35. **`dict(random.sample(d.items(), len(d)))`** -> Перемешивание словаря (создание нового словаря со случайным порядком ключей).
36. **`with contextlib.redirect_stdout(io.StringIO()): exec('code')`** -> Выполнение куска кода в виде строки, подавляя любой его вывод в консоль.
37. **`[lst[i:i+n] for i in range(0, len(lst), n)]`** -> Разделение списка на "чанки" — списки одинакового размера по `n` элементов.
38. **`socket.create_connection((host, port), timeout=2)`** -> Проверка, доступен ли TCP-порт на указанном хосте (быстрая альтернатива `ping`).
39. **`s.replace('from', 'to', 1)`** -> Замена только первого вхождения подстроки в строке.
40. **`all(isinstance(x, (int, float)) for x in lst)`** -> Проверка, что все элементы в списке являются числами (`int` или `float`).
41. **`groups = defaultdict(list); [groups[k].append(v) for k, v in data]`** -> Группировка списка кортежей `(ключ, значение)` в словарь `{ключ: [значения]}`.
42. **`copy = pickle.loads(pickle.dumps(obj, -1))`** -> Быстрое и глубокое копирование объекта, работающее для большинства стандартных типов.
43. **`r = requests.post(url, json=payload)`** -> Отправка POST-запроса с автоматической сериализацией словаря `payload` в JSON-тело.
44. **`is_symlink = Path(p).is_symlink()`** -> Проверка, является ли путь `p` символической ссылкой, а не реальным файлом или папкой.
45. **`merged = {**d1, **d2, **d3}`** -> Быстрое объединение нескольких словарей. Значения из последующих словарей перезаписывают значения из предыдущих при совпадении ключей.
46. **`is_sorted = all(a <= b for a, b in zip(lst, lst[1:]))`** -> Эффективная проверка, отсортирован ли список по возрастанию, без создания копий списка.
47. **`matches = re.findall(r'\d+', text)`** -> Поиск всех непересекающихся вхождений по регулярному выражению в строке и возврат их в виде списка строк.
48. **`domain = urlparse(url).netloc`** -> Простое и надёжное извлечение домена (например, `www.example.com`) из полного URL.
49. **`nums = list(map(int, str_list))`** -> Компактное преобразование списка строк в список целых чисел.
50. **`rows = list(csv.DictReader(open('file.csv')))`** -> Чтение CSV-файла в виде списка словарей, где ключами являются заголовки столбцов.
51. **`bits = f'{num:08b}'`** -> Преобразование целого числа в его двоичное представление в виде строки, дополненной нулями до 8 символов.
52. **`json.dump(obj, open('data.json', 'w'), indent=2)`** -> Сохранение объекта Python (словаря, списка) в JSON-файл с красивым форматированием (отступ в 2 пробела).
53. **`lines = [l for l in lines if l.strip()]`** -> Фильтрация списка строк, удаляющая пустые строки и строки, состоящие только из пробельных символов.
54. **`params = dict(parse_qsl('a=1&b=2'))`** -> Преобразование строки URL-запроса (`query string`) в словарь.
55. **`uniq = [s for s in seq if not (s in seen or seen.add(s))]`** -> Эффективное удаление дубликатов из последовательности с сохранением исходного порядка (требует `seen = set()`).
56. **`idx = max(range(len(lst)), key=lst.__getitem__)`** -> Нахождение индекса максимального элемента в списке без дополнительного поиска.
57. **`is_nested = all(isinstance(i, list) for i in lst)`** -> Проверка, является ли список "вложенным", т.е. все его элементы — это списки.
58. **`clean = re.sub(r'\W+', '', text)`** -> Удаление из строки всех символов, не являющихся буквами, цифрами или знаком подчёркивания.
59. **`signal.alarm(2); try: ... except: ...`** -> Ограничение времени выполнения блока кода (только для Unix-подобных систем).
60. **`fields = [f.name for f in dataclasses.fields(MyClass)]`** -> Получение списка имён всех полей для заданного дата-класса.